# -*- coding: utf-8 -*-
"""GA_Optimizer_.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ep-_ah8ZHqaHL8E9KiVK8EgisDufAao-
"""

import random
import copy
import numpy as np
import pandas as pd

class GeneticAlgorithm:
    def __init__(self, verbose = True):
        #hiển thị thông tin có chi tiết hay không, nếu trả True thì hiện tất cả thông báo nếu là False thì chỉ trả về kết quả mà không hiện gì thêm
        #ví dụ bạn gọi: ga = GeneticAlgorithm(verbose = True) nó sẽ in ra tất cả các print của hàm, nhưng nếu là False thì không in gì cả.
        self.verbose = verbose
    def doc_do_thi_tu_csv(self,file_path):
        #tham số: file_path: đường dẫn đến file CSV chứa dữ liệu đồ thị
        # Đọc file CSV
        df = pd.read_csv(file_path)

        # Khởi tạo đồ thị
        do_thi = {}

        # Duyệt qua từng dòng trong dataframe
        for _, row in df.iterrows():
            v_from = str(row['v_from'])
            v_to = str(row['v_to'])
            weight = float(row['weight'])

            # Thêm cạnh vào đồ thị
            if v_from not in do_thi:
                do_thi[v_from] = {}
            do_thi[v_from][v_to] = weight

            # Đảm bảo tất cả các node đều có trong đồ thị (kể cả node chỉ có cạnh đi vào)
            if v_to not in do_thi:
                do_thi[v_to] = {}

        return do_thi
    #trả về đồ thị dạng danh sách kề
    # Các phương thức khác của thuật toán di truyền sẽ được định nghĩa ở đây
    # HÀM 1: Khởi tạo quần thể - đường đi để lai ghép,đột biến...
    #keys: tên đỉnh
    #values: trọng số các đỉnh kề/chi phí các kết nối
    def khoi_tao_quan_the(self, do_thi, diem_bat_dau, diem_ket_thuc, kich_thuoc_quan_the):
        #Khởi tạo quần thể gồm nhiều đường đi ngẫu nhiên từ start đến end
        """   Khởi tạo đối tượng GeneticAlgorithm với đồ thị và các tham số cần thiết.
        Parameters:
        - do_thi: dict, biểu diễn đồ thị dưới dạng từ điển kề
        - diem_bat_dau: điểm bắt đầu (node)
        - diem_ket_thuc: điểm kết thúc (node)
        - kich_thuoc_quan_the: kích thước quần thể ban đầu"""
        quan_the = []
        for _ in range(kich_thuoc_quan_the): #không quan tâm chỉ số nên dùng _
            duong_di = self._tao_duong_di_ngau_nhien(do_thi, diem_bat_dau, diem_ket_thuc)
            if duong_di:  # Chỉ thêm đường đi hợp lệ
                quan_the.append(duong_di)
        # Nếu không tạo đủ, thêm các đường đi đơn giản
        while len(quan_the) < kich_thuoc_quan_the:
            duong_don_gian = [diem_bat_dau, diem_ket_thuc]
            if self._kiem_tra_duong_di_hop_le(duong_don_gian, do_thi):
                quan_the.append(duong_don_gian)
            else:
                break
        return quan_the
        """trả về một danh sách các đường đi hợp lệ ban đầu với mỗi đường đi là một cá thể trong quần thể và mỗi đường đi là một list các node [start, n1, n2,...,end] """


    def _tao_duong_di_ngau_nhien(self, do_thi, diem_bat_dau, diem_ket_thuc):
        #Parameters:
        #- do_thi: dict, biểu diễn đồ thị dưới dạng từ điển kề
        #- diem_bat_dau: điểm bắt đầu (node)
        #- diem_ket_thuc: điểm kết thúc (node)


        #hàm phức tạp phụ trợ cần ẩn đi
        #Tạo đường đi ngẫu nhiên
        if diem_bat_dau not in do_thi: #nếu người dùng có nhỡ truyền nhầm đầu vào
            return None
        duong_di = [diem_bat_dau] #danh sách các đỉnh
        diem_hien_tai = diem_bat_dau
        da_tham = set([diem_bat_dau]) #dùng set vì nó nhanh duyệt luôn hằng số không phải tuần tự.
        so_buoc_toi_da = len(do_thi) * 2  # Tránh vòng lặp vô hạn
        for _ in range(so_buoc_toi_da):
            if diem_hien_tai == diem_ket_thuc:
                break
            # Lấy các điểm kế tiếp có thể đi
            cac_lua_chon = list(do_thi.get(diem_hien_tai, {}).keys())
            #lấy các đỉnh kề với đỉnh hiện tại
            #nếu diem_hien_tai không có trong do_thi thì trả về {} không mắc lỗi
            if not cac_lua_chon: #nếu không có lựa chọn nào để đi tiếp thì dừng lại
                break

            # Ưu tiên điểm chưa thăm
            #lọc ra các điểm chưa thăm
            chua_tham = [diem for diem in cac_lua_chon if diem not in da_tham]
            if chua_tham: #nếu còn điểm chưa thăm thì chọn ngẫu nhiên 1 điểm trong số đó
                diem_tiep_theo = random.choice(chua_tham)
            else:
                diem_tiep_theo = random.choice(cac_lua_chon)
            duong_di.append(diem_tiep_theo)
            da_tham.add(diem_tiep_theo)
            diem_hien_tai = diem_tiep_theo
        # Chỉ trả về đường đi đến được đích
        return duong_di if duong_di[-1] == diem_ket_thuc else None
	#Nếu thành công nó sẽ trả về đường đi hợp lệ từ start đến end nếu thất bại nó sẽ trả về rỗng tức là không hề có đường đi hợp lệ

    def _kiem_tra_duong_di_hop_le(self,duong_di, do_thi):
    #parameters: duong_di: đường đi cần kiểm tra tính hợp lệ
    #do_thi: đồ thị chứa đường đi
        #Kiểm tra đường đi có hợp lệ không
        if len(duong_di) < 2: #ít hơn 2 thì không có gì để tìm
            return False
        for i in range(len(duong_di) - 1):
            if duong_di[i+1] not in do_thi.get(duong_di[i], {}):
                #trong đó do_thi.get(duong_di[i], {}): trả về danh sách các đỉnh kề với đỉnh i hiện tại
                #tức là nếu đỉnh i+1 không nằm trong danh sách các đỉnh kề với đỉnh i hiện tại
                return False
        return True
    """Trả về hợp lệ hoặc không"""
    # HÀM 2: Tính fitness
    def tinh_fitness(self,quan_the, do_thi):
        """ quan_the: quần thể các đường đi có được từ hàm khởi tạo quần thể
    do_thi: đồ thị để tính chi phí các cạnh"""
        #Tính fitness cho toàn bộ quần thể (nghịch đảo tổng chi phí)
        danh_sach_fitness = []
        for duong_di in quan_the:
            fitness = self._tinh_fitness_duong_di(duong_di, do_thi)
            danh_sach_fitness.append(fitness)

        return danh_sach_fitness
    """trả về danh sách các giá trị fitness của đường đi, nếu đường đi không hợp lệ thì fitness = 0.0"""
    def _tinh_fitness_duong_di(self,duong_di, do_thi):
	#duong_di: 1 đường đi trong đồ thị
	#do_thi: đồ thị
        #Tính fitness cho một đường đi cụ thể
        if not duong_di or len(duong_di) < 2:
            #nếu đường đi rỗng hoặc không tồn tại hoặc độ dài đường đi có mỗi 1 nút
            return 0.0

        tong_chi_phi = 0.0
        for i in range(len(duong_di) - 1):
            diem_hien_tai = duong_di[i]
            diem_ke_tiep = duong_di[i + 1]

            # Kiểm tra kết nối hợp lệ
            if diem_ke_tiep not in do_thi.get(diem_hien_tai, {}):
                return 0.0
            tong_chi_phi += do_thi[diem_hien_tai][diem_ke_tiep] #cộng kinh phí vô

        # Fitness = nghịch đảo chi phí (chi phí càng thấp càng tốt)
        return 1.0 / tong_chi_phi if tong_chi_phi > 0 else 0.0
	#Giá trị fitness = 1/ tongchiphi

    # HÀM 3: Chọn lọc
    def chon_loc(self,quan_the, danh_sach_fitness, phuong_phap='tournament'):
        """quan_the: quần thể hiện tại.
        danh_sach_fitness: danh sách giá trị fitness tương ứng từng đường đi
        phương pháp: chọn phương pháp """
        #Chọn lọc cá thể cho thế hệ tiếp theo

        if phuong_phap == 'tournament': #chọn ngẫu nhiên nhóm cá thể và chọn cá thể tốt nhất là winner
            return self._chon_loc_tournament(quan_the, danh_sach_fitness)
        elif phuong_phap == 'roulette':
            """Mỗi cá thể có một 'miếng bánh' trên bánh xe roulette,
            kích thước miếng bánh tỷ lệ với fitness của cá thể đó.
            Cá thể nào có fitness cao hơn thì có miếng bánh lớn hơn
            và dễ được chọn hơn."""
            return self._chon_loc_roulette(quan_the, danh_sach_fitness)
        else:
            return self._chon_loc_tournament(quan_the, danh_sach_fitness)  # Mặc định
            """nếu người dùng gõ vào phương pháp là tournament thì thực hiện hàm chọn lọc tournament,
            còn nếu roulette thì thực hiện hàm roulette còn nếu các khác hoặc gõ sai hoặc không gõ gì thì mặc định là tournament."""

    def _chon_loc_tournament(self,quan_the, danh_sach_fitness, kich_thuoc_tournament=2):
    #quần thể, danh sách các chỉ số fitness và số cá thể tham gia mỗi tournament mặc định là 2 để không lớn hơn kích thước quần thể
        quan_the_moi = []

        for _ in range(len(quan_the)):
            # Chọn ngẫu nhiên k cá thể
            cac_chi_so = random.sample(range(len(quan_the)), kich_thuoc_tournament)
            #tập hợp lấy mẫu và kích thước lấy mẫu cho tournament
            cac_ca_the = [quan_the[i] for i in cac_chi_so]
            #ở đây ta có  mỗi quần thể là tùy chỉ số tournament nên có 2-3 hoặc nhiều hơn chỉ số [1,2,9,0...]
            #tính fitness của các các chỉ số của các đường đi trong quần thể để tìm ra chỉ số tốt nhất
            cac_fitness = [danh_sach_fitness[i] for i in cac_chi_so]

            # Chọn cá thể có fitness cao nhất
            chi_so_tot_nhat = cac_chi_so[np.argmax(cac_fitness)]
            quan_the_moi.append(quan_the[chi_so_tot_nhat])

        return quan_the_moi
	#trả về danh sách đường đi mới sau khi chọn lọc, có cùng kích thước với quần thể ban đầu

    def _chon_loc_roulette(self, quan_the, danh_sach_fitness):
	#quần thể, danh sách chỉ số fitness mỗi đường đi
        # Tránh chia cho 0
        tong_fitness = sum(danh_sach_fitness)
        if tong_fitness == 0:
            return quan_the.copy()

        xac_suat = [fitness / tong_fitness for fitness in danh_sach_fitness]

        # Chọn lại với xác suất tỷ lệ fitness
        chi_so_duoc_chon = np.random.choice(
            range(len(quan_the)), #danh sách chỉ số có thể chọn
            size=len(quan_the), #số lượng cần chọn
            p=xac_suat #xác suất cho từng chỉ số
        ) #chọn ngẫu nhiên với xác suất tỷ lệ với fitness

        return [quan_the[i] for i in chi_so_duoc_chon]
	#trả về danh sách quần thể mới sau khi chọn lọc có cùng kích thước với quần thể ban đầu
    def _sua_duong_di(self,duong_di, diem_bat_dau, diem_ket_thuc,do_thi):
	#đường đi, điểm bắt đầu của đường đi, điểm kết thúc đường đi, đồ thị chứa đường đi trên
        #Sửa chữa đường đi để đảm bảo tính hợp lệ
        if not isinstance(duong_di, list):
            duong_di = [diem_bat_dau]
        # Lọc chỉ lấy các phần tử là string (node)
        duong_di = [diem for diem in duong_di if isinstance(diem, str)]
        if not duong_di or duong_di[0] != diem_bat_dau:
            duong_di = [diem_bat_dau]
        # Loại bỏ node trùng lặp, giữ thứ tự đầu tiên
        da_xuat_hien = set()
        duong_di_moi = []

        for diem in duong_di:
            if diem not in da_xuat_hien and isinstance(diem, str):  # CHỈ thêm string
                duong_di_moi.append(diem)
                da_xuat_hien.add(diem)

        # Đảm bảo kết thúc tại đích
        if duong_di_moi or duong_di_moi[-1] != diem_ket_thuc:
            # Tìm đường từ điểm cuối đến đích
            duong_di_moi = self._noi_den_dich(duong_di_moi, do_thi, diem_ket_thuc)
        return duong_di_moi
	#trả về đường đi mới sau khi đã sửa chữa loại các nút trùng nhau, đảm bảo start và end đều hợp lệ

    def _noi_den_dich(self,duong_di, do_thi, diem_ket_thuc):
	#đường đi, đồ thị và điểm kết thúc của đường đi trong đồ thị
        #Nối đường đi hiện tại đến điểm kết thúc
        if not duong_di:
            return duong_di

        diem_hien_tai = duong_di[-1]

        # Nếu đã đến đích
        if diem_hien_tai == diem_ket_thuc:
            return duong_di

        # Thử đi thẳng đến đích
        if diem_ket_thuc in do_thi.get(diem_hien_tai, {}):
            return duong_di + [diem_ket_thuc]

        # Tìm đường ngắn từ điểm hiện tại đến đích
        # Corrected: Use do_thi directly, not self.do_thi, as do_thi is passed as a parameter.
        # Also, limit the search to avoid infinite loops and ensure path doesn't grow indefinitely.
        temp_duong_di = list(duong_di) # Create a mutable copy
        visited_nodes = set(temp_duong_di)
        current_node = diem_hien_tai

        for _ in range(len(do_thi) * 2): # Heuristic to prevent extremely long paths
            if current_node == diem_ket_thuc:
                break

            possible_next_nodes = list(do_thi.get(current_node, {}).keys())
            if not possible_next_nodes:
                break

            # Prioritize unvisited nodes, then any node
            unvisited_options = [node for node in possible_next_nodes if node not in visited_nodes]

            next_node = None
            if diem_ket_thuc in possible_next_nodes: # If target is directly reachable, take it
                next_node = diem_ket_thuc
            elif unvisited_options:
                next_node = random.choice(unvisited_options)
            else:
                next_node = random.choice(possible_next_nodes)

            temp_duong_di.append(next_node)
            visited_nodes.add(next_node)
            current_node = next_node

        return temp_duong_di if temp_duong_di[-1] == diem_ket_thuc else duong_di # Return original if connection failed
	#trả về đường đi đã được nối đến điểm kết thúc thành công
    # HÀM 4: Lai ghép
    def lai_ghep(self,quan_the, do_thi, diem_bat_dau, diem_ket_thuc,ti_le_lai_ghep=0.8):
    #quan_the: quần thể sau khi đã chọn lọc
    #do_thi: đồ thị để sửa chữa đường đi con
    #diem_bat_dau: điểm bắt đầu
    #diem_ket_thuc: điểm kêt thúc
    #ti_le_lai_ghep: tỷ lệ lai ghép từ 0-1 ở 0.8 thì có 80% cặp được lai ghép
        #Lai ghép các cặp cha mẹ để tạo ra thế hệ con
        quan_the_moi = []

        # Xáo trộn ngẫu nhiên
        random.shuffle(quan_the)

        for i in range(0, len(quan_the), 2):
            if i + 1 < len(quan_the) and random.random() < ti_le_lai_ghep:
                cha = quan_the[i]
                me = quan_the[i + 1]

                con_1, con_2 = self._lai_ghep_cap(cha, me, do_thi, diem_bat_dau, diem_ket_thuc)
                quan_the_moi.extend([con_1, con_2])
            else:
                # Giữ nguyên nếu không lai ghép
                if i < len(quan_the):
                    quan_the_moi.append(quan_the[i])
                if i + 1 < len(quan_the):
                    quan_the_moi.append(quan_the[i + 1])

        return quan_the_moi
	#quần thể sau lai ghép: có thể có nhiều cá thể hơn ban đầu cho mỗi cặp sinh ra 2 con

    def _lai_ghep_cap(self,duong_di_1, duong_di_2, do_thi, diem_bat_dau, diem_ket_thuc):
	#duong_di_1: đường đi của cha
    #duong_di_2: đường đi của mẹ
	#do_thi: đồ thị để sửa đường đi con
    #diem_bat_dau: điểm bắt đầu bắt buộc
    #diem_ket_thuc: điểm kết thúc bắt buộc
        #Lai ghép một cặp đường đi
        if len(duong_di_1) < 3 or len(duong_di_2) < 3:
            # If paths are too short, direct crossover might not be meaningful.
            # Attempt to create valid paths from start to end by combining elements
            # to ensure children are not empty or too trivial, then repair them.
            con_1 = [diem_bat_dau, diem_ket_thuc]
            con_2 = [diem_bat_dau, diem_ket_thuc]
            con_1 = self._sua_duong_di(con_1, diem_bat_dau, diem_ket_thuc, do_thi)
            con_2 = self._sua_duong_di(con_2, diem_bat_dau, diem_ket_thuc, do_thi)
            return con_1, con_2

        # Chọn điểm cắt ngẫu nhiên (không phải điểm đầu/cuối)
        diem_cat_1 = random.randint(1, len(duong_di_1) - 2)
        diem_cat_2 = random.randint(1, len(duong_di_2) - 2)

        # Tạo con 1: phần đầu của cha + phần cuối của mẹ (unique nodes)
        con_1 = duong_di_1[:diem_cat_1].copy()
        for diem in duong_di_2:
            if diem not in con_1:
                con_1.append(diem)

    # Ví dụ: Duyệt qua duong_di_2: ['F', 'E', 'D', 'C', 'B', 'A']
    # 'F' not in ['A','B','C']? okey → thêm → ['A','B','C','F']
    # 'E' not in ['A','B','C','F']? okey → thêm → ['A','B','C','F','E']
    # 'D' not in ['A','B','C','F','E']? okey → thêm → ['A','B','C','F','E','D']
    # 'C' not in ['A','B','C','F','E','D']? có ròi → bỏ qua
    # ...
        # Tạo con 2: phần đầu của mẹ + phần cuối của cha (unique nodes)
        con_2 = duong_di_2[:diem_cat_2].copy()
        for diem in duong_di_1:
            if diem not in con_2:
                con_2.append(diem)

        # Sửa chữa đường đi để hợp lệ
        con_1 = self._sua_duong_di(con_1, diem_bat_dau, diem_ket_thuc, do_thi)
        con_2 = self._sua_duong_di(con_2, diem_bat_dau, diem_ket_thuc, do_thi)

        return con_1, con_2
	#trả về cặp đường đi con sau khi lai ghép xong

    # HÀM 5: Đột biến
    def dot_bien(self,quan_the, do_thi, ti_le_dot_bien, diem_bat_dau, diem_ket_thuc):
	#quan_the: quần thể sau lai ghép
	#do_thi: đồ thị để kiểm tra tính hợp lệ
	#ti_le_dot_bien: tỷ lệ đột biến từ 0-1
	#diem_bat_dau: điểm bắt đầu
	#diem_ket_thuc: điểm kết thúc

        #Áp dụng đột biến cho quần thể
        quan_the_moi = []

        for duong_di in quan_the:
            if random.random() < ti_le_dot_bien:
                duong_di_da_dot_bien = self._dot_bien_duong_di(duong_di, do_thi, diem_bat_dau, diem_ket_thuc)
                quan_the_moi.append(duong_di_da_dot_bien)
            else:
                quan_the_moi.append(duong_di)

        return quan_the_moi
	#trả về quần thể mới là quần thể sau khi đột biến
    def _dot_bien_duong_di(self,duong_di, do_thi, diem_bat_dau, diem_ket_thuc):
	#duong_di: đường đi cần đột biến
	#do_thi: đồ thị để kiểm tra tính hợp lệ
	#diem_bat_dau: điểm bắt đầu
	#diem_ket_thuc: điểm kết thúc

        #Đột biến một đường đi bằng cách thay đổi ngẫu nhiên 1 node trung gian
        if len(duong_di) <= 3:  # Quá ngắn để đột biến
            return duong_di

        # Chọn vị trí đột biến (không phải điểm đầu/cuối)
        vi_tri_dot_bien = random.randint(1, len(duong_di) - 2)

        diem_truoc = duong_di[vi_tri_dot_bien - 1]
        diem_sau = duong_di[vi_tri_dot_bien + 1]

        # Tìm các điểm có thể thay thế
        cac_diem_thay_the = []
        for diem_lan_can in do_thi.get(diem_truoc, {}):
            # Ensure diem_lan_can is a valid intermediate node connection
            # It should connect from diem_truoc AND connect to diem_sau
            # Also, avoid creating immediate loops or already visited nodes in the current segment if possible
            if diem_lan_can != diem_sau and \
               diem_lan_can not in duong_di[1:vi_tri_dot_bien] and \
               diem_sau in do_thi.get(diem_lan_can, {}):
                cac_diem_thay_the.append(diem_lan_can)

        if cac_diem_thay_the:
            diem_moi = random.choice(cac_diem_thay_the)
            duong_di_moi = (duong_di[:vi_tri_dot_bien] +
                            [diem_moi] +
                            duong_di[vi_tri_dot_bien + 1:])
            return self._sua_duong_di(duong_di_moi, diem_bat_dau, diem_ket_thuc, do_thi)
        # phải sửa lại đương đi bởi vì có thể sau khi đột biến nó không còn hợp lệ nữa
        # ( hai đỉnh đó chưa chưa chắc có nối nhau được không vì một trong hai đã bị đột biến thành đỉnh mới)
        #đồng thời xem đột biến xong có gây trùng lặp không
        # có khi đột biến sẽ gây mất đỉnh kết thúc cũng phải sửa để nối đến đích
        return duong_di
	#đường đi sau khi đột biến (có thể không khác gì cái cũ nếu không đột biến được)
    # HÀM 6: Thuật toán GA chính
    def giai_thuat_GA(self, do_thi,diem_bat_dau, diem_ket_thuc,kich_thuoc_quan_the=50, so_the_he_toi_da=100,
                    ti_le_dot_bien=0.1, ti_le_lai_ghep=0.8):

    #Giải thuật Di Truyền cho bài toán tìm đường đi tối ưu
	#do_thi: đồ thị đầu vào
    #diem_bat_dau: điểm bắt đầu
	#diem_ket_thuc: điểm kết thúc
	#kich_thuoc_quan_the: kích thước quần thể
	#so_the_he_toi_da: số thế hệ tối đa
	#ti_le_dot_bien: tỷ lệ đột biến
	#ti_le_lai_ghep: tỷ lệ lai ghép

        # Bước 1: Khởi tạo quần thể
        quan_the = self.khoi_tao_quan_the(do_thi, diem_bat_dau, diem_ket_thuc, kich_thuoc_quan_the)

        duong_di_tot_nhat = None
        fitness_tot_nhat = 0.0 # Initialize as float

        for the_he in range(so_the_he_toi_da):
            # Bước 2: Tính fitness
            danh_sach_fitness = self.tinh_fitness(quan_the, do_thi)

            # Check if there are any valid paths with positive fitness
            if not danh_sach_fitness or max(danh_sach_fitness) == 0:
                if self.verbose: print(f"Generation {the_he}: No valid paths with positive fitness found. Re-initializing population.")
                quan_the = self.khoi_tao_quan_the(do_thi, diem_bat_dau, diem_ket_thuc, kich_thuoc_quan_the)
                danh_sach_fitness = self.tinh_fitness(quan_the, do_thi)
                # If still no valid paths after re-initialization, break to avoid infinite loop
                if not danh_sach_fitness or max(danh_sach_fitness) == 0:
                    if self.verbose: print("Could not initialize a valid population. Exiting.")
                    break

            # Cập nhật giải pháp tốt nhất
            chi_so_tot_nhat = np.argmax(danh_sach_fitness)
            fitness_hien_tai = danh_sach_fitness[chi_so_tot_nhat]

            if fitness_hien_tai > fitness_tot_nhat:
                fitness_tot_nhat = fitness_hien_tai
                duong_di_tot_nhat = quan_the[chi_so_tot_nhat]
                if self.verbose: print(f"Generation {the_he}: Found better path, cost = {1/fitness_tot_nhat:.2f}")
            elif self.verbose and fitness_hien_tai > 0: # Print current best path cost even if not better than overall best
                if self.verbose: print(f"Generation {the_he}: Current best path cost = {1/fitness_hien_tai:.2f}")

            # Bước 3: Chọn lọc
            quan_the = self.chon_loc(quan_the, danh_sach_fitness, 'tournament')

            # Bước 4: Lai ghép
            quan_the = self.lai_ghep(quan_the,do_thi,diem_bat_dau,diem_ket_thuc, ti_le_lai_ghep)

            # Bước 5: Đột biến
            quan_the = self.dot_bien(quan_the, do_thi,ti_le_dot_bien, diem_bat_dau,diem_ket_thuc)

            # Elitism: Giữ lại cá thể tốt nhất
            if duong_di_tot_nhat and len(quan_the) > 0:
                # Ensure the best path from the previous generation is carried over
                # Make sure duong_di_tot_nhat itself is a valid path within the current graph context
                # This also helps prevent errors if the initial best path somehow becomes invalid
                if self._kiem_tra_duong_di_hop_le(duong_di_tot_nhat, do_thi):
                    quan_the[0] = duong_di_tot_nhat

        # After loop, ensure duong_di_tot_nhat is valid and cost is calculated from it
        if duong_di_tot_nhat and self._kiem_tra_duong_di_hop_le(duong_di_tot_nhat, do_thi):
            final_fitness = self._tinh_fitness_duong_di(duong_di_tot_nhat, do_thi)
            chi_phi_tot_nhat = 1.0 / final_fitness if final_fitness > 0 else float('inf')
        else:
            duong_di_tot_nhat = []
            chi_phi_tot_nhat = float('inf')

        return duong_di_tot_nhat, chi_phi_tot_nhat
	#trả về đường đi tốt nhất và chi phí float đường đi tốt nhất
    # Ví dụ sử dụng thuật toán di truyền
    def chay_test_day_du(self,verbose=True):
	#parameter: verbose có muốn hiển thị chi tiết test hay không
        #Chạy test đầy đủ 6 bước và kiểm tra tính hợp lệ
        ga = GeneticAlgorithm(verbose=verbose)

        # Đồ thị mẫu
        do_thi_giao_thong = {
            's': {'2': 5, '4': 5},
            '2': {'s': 5, '3': 6, '5': 3},
            '3': {'2': 6, 't': 6},
            '4': {'s': 5, '3': 3, '5': 1},
            '5': {'2': 3, '4': 1, 't': 6},
            't': {'3': 6, '5': 6}
        }

        if verbose:
            print("=" * 70)
            print("Check for results")
            print("=" * 70)
            print("sample graph:")
            for node, neighbors in do_thi_giao_thong.items():
                print(f"  {node}: {list(neighbors.items())}")
            print(f"Start point: 's'")
            print(f"End point: 't'")
            print()


        # Test 1: Khởi tạo quần thể
        if verbose:
            print("1.Initialize population")
            print("-" * 40)

        quan_the = ga.khoi_tao_quan_the(do_thi_giao_thong, 's', 't', 6)

        if verbose:
            print(f"Population size: {len(quan_the)}")
            for i, duong_di in enumerate(quan_the):
                print(f"Individual {i+1}: {' -> '.join(duong_di)}")

        # Kiểm tra tính hợp lệ của quần thể
        hop_le_count = sum(1 for duong_di in quan_the if ga._kiem_tra_duong_di_hop_le(duong_di, do_thi_giao_thong))
        if verbose:
            print(f"Valid individual: {hop_le_count}/{len(quan_the)}")
            print()


        # Test 2: Tính fitness
        if verbose:
            print("2. fitness calculation")
            print("-" * 40)

        danh_sach_fitness = ga.tinh_fitness(quan_the, do_thi_giao_thong)

        if verbose:
            for i, (duong_di, fitness) in enumerate(zip(quan_the, danh_sach_fitness)):
                chi_phi = 1/fitness if fitness > 0 else "Infinity"
                print(f"Individual {i+1}: {' -> '.join(duong_di):<25} -> Fitness: {fitness:.4f}, cost: {chi_phi}")
            print()


        # Test 3: Chọn lọc
        if verbose:
            print("3. selection")
            print("-" * 40)

        quan_the_chon_loc = ga.chon_loc(quan_the, danh_sach_fitness, 'tournament')

        if verbose:
            print(f"after selection: {len(quan_the_chon_loc)} individuals")
            for i, duong_di in enumerate(quan_the_chon_loc[:3]):  # Hiển thị 3 cá thể đầu
                print(f"Individual {i+1}: {' -> '.join(duong_di)}")
            print()

        # Test 4: Lai ghép
        if verbose:
            print("4.Crossover")
            print("-" * 40)

        quan_the_lai_ghep = ga.lai_ghep(quan_the_chon_loc, do_thi_giao_thong, 's', 't', 0.8)

        if verbose:
            print(f"after crossover: {len(quan_the_lai_ghep)} individuals")
            for i, duong_di in enumerate(quan_the_lai_ghep[:4]):  # Hiển thị 4 cá thể đầu
                print(f"individuals {i+1}: {' -> '.join(duong_di)}")

            # Kiểm tra tính hợp lệ sau lai ghép
            hop_le_sau_lai_ghep = sum(1 for duong_di in quan_the_lai_ghep if ga._kiem_tra_duong_di_hop_le(duong_di, do_thi_giao_thong))
            print(f"Valid individuals after crossover: {hop_le_sau_lai_ghep}/{len(quan_the_lai_ghep)}")
            print()


        # Test 5: Đột biến
        if verbose:
            print("5. Mutation")
            print("-" * 40)

        quan_the_dot_bien = ga.dot_bien(quan_the_lai_ghep, do_thi_giao_thong, 0.3, 's', 't')

        if verbose:
            print(f"After mutation: {len(quan_the_dot_bien)} individuals")
            for i, duong_di in enumerate(quan_the_dot_bien[:3]):  # Hiển thị 3 cá thể đầu
                print(f"Individual {i+1}: {' -> '.join(duong_di)}")
        # Kiểm tra tính hợp lệ sau đột biến
            hop_le_sau_dot_bien = sum(1 for duong_di in quan_the_dot_bien if ga._kiem_tra_duong_di_hop_le(duong_di, do_thi_giao_thong))
            print(f"Valid individuals after mutation: {hop_le_sau_dot_bien}/{len(quan_the_dot_bien)}")
            print()


        # Test 6: Chạy toàn bộ thuật toán GA
        if verbose:
            print("6. Genetic Algorithm Execution")
            print("-" * 40)
            print("running genetic algorithm...")

        duong_di_tot_nhat, chi_phi_tot_nhat = ga.giai_thuat_GA(
            do_thi=do_thi_giao_thong,
            diem_bat_dau='s',
            diem_ket_thuc='t',
            kich_thuoc_quan_the=20,
            so_the_he_toi_da=50,
            ti_le_dot_bien=0.15,
            ti_le_lai_ghep=0.8
        )


        # KIỂM TRA TÍNH HỢP LỆ CỦA KẾT QUẢ
        if verbose:
            print("\n" + "=" * 70)
            print("result validation")
            print("=" * 70)

        # Kiểm tra 1: Đường đi có hợp lệ không
        hop_le = ga._kiem_tra_duong_di_hop_le(duong_di_tot_nhat, do_thi_giao_thong)

        if verbose:
            print(f"1. Valid path: {'agree' if hop_le else 'disagree'}")
            if not hop_le:
                print("  Reason: Contains non-existent edges in graph")

        # Kiểm tra 2: Bắt đầu và kết thúc đúng
        bat_dau_dung = duong_di_tot_nhat[0] == 's' if duong_di_tot_nhat else False
        ket_thuc_dung = duong_di_tot_nhat[-1] == 't' if duong_di_tot_nhat else False

        if verbose:
            print(f"2. Correct start ('s'): {'agree' if bat_dau_dung else 'disagree'}")
            print(f"3. Correct end ('t'): {'agree' if ket_thuc_dung else 'disagree'}")

        # Kiểm tra 3: Tính chi phí thực tế
        chi_phi_thuc_te = 0
        chi_tiet_chi_phi = []
        if hop_le and bat_dau_dung and ket_thuc_dung: # Only calculate if path is fundamentally valid
            for i in range(len(duong_di_tot_nhat) - 1):
                chi_phi_canh = do_thi_giao_thong[duong_di_tot_nhat[i]][duong_di_tot_nhat[i+1]]
                chi_phi_thuc_te += chi_phi_canh
                chi_tiet_chi_phi.append(f"{duong_di_tot_nhat[i]}→{duong_di_tot_nhat[i+1]}({chi_phi_canh})")
        else:
            chi_phi_thuc_te = float('inf')

        if verbose:
            print(f"4. Real cost: {chi_phi_thuc_te}")
            print(f"Details: {' + '.join(chi_tiet_chi_phi)} = {chi_phi_thuc_te}")

        # Kiểm tra 4: So sánh với chi phí thuật toán
        if verbose:
            print(f"5. Algorithm cost: {chi_phi_tot_nhat:.2f}")
            print(f"Matches real cost: {'agree' if abs(chi_phi_thuc_te - chi_phi_tot_nhat) < 0.01 else 'disagree'}")

        # Kiểm tra 5: So sánh với đường đi tối ưu lý thuyết
        if verbose:
            print("\ncomparison:")
            print("-" * 40)

        # Các đường đi có thể và chi phí
        cac_duong_di_co_the = [
            (['s', '2', '5', 't'], "5 + 3 + 6", 14),
            (['s', '4', '5', 't'], "5 + 1 + 6", 12),
            (['s', '2', '3', 't'], "5 + 6 + 6", 17),
            (['s', '4', '3', 't'], "5 + 3 + 6", 14)
        ]

        if verbose:
            for i, (duong_di, cong_thuc, chi_phi) in enumerate(cac_duong_di_co_the):
                trang_thai = " (optimal)" if chi_phi == 12 else ""
                print(f"{i+1}. {' -> '.join(duong_di):<15} | {cong_thuc} = {chi_phi}{trang_thai}")

        # Đánh giá kết quả
        if verbose:
            print(f"\nResult evaluation:")
            print("-" * 40)
            print(f"Found path: {' -> '.join(duong_di_tot_nhat) if duong_di_tot_nhat else 'None'}")
            print(f"Cost: {chi_phi_thuc_te}")

            if chi_phi_thuc_te == 12:
                print("Found optimal path")
            elif chi_phi_thuc_te <= 14:
                print("Path close to optimal")
            elif chi_phi_thuc_te <= 16:
                print("Path can be improved")
            else:
                print("Not optimal: needs parameter adjustment or more generations/population size")

        # Kết luận
        if verbose:
            print("\n" + "=" * 70)
            print("Test completed")
            print("=" * 70)

        path_length = len(duong_di_tot_nhat) if duong_di_tot_nhat else 0
        return  duong_di_tot_nhat ,chi_phi_thuc_te, chi_phi_tot_nhat, hop_le,bat_dau_dung,ket_thuc_dung,path_length
        #trả về kết quả chi tiết:
		#đường đi tốt nhất, chi phí thực tế tính từ đồ thị,
        #chi phí tốt nhất, kiểm tra xem đường đi hợp lệ không,
        #có bắt đầu bằng s và kết thúc bằng t không, cuối cùng là số nốt trong đường đi."""

"""from"""